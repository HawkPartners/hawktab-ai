# Decipher API Exploration

## Purpose

This document explores the Forsta Decipher REST API to understand how it could transform HawkTab AI's architecture. Instead of parsing uploaded CSV data maps and inferring skip logic, we may be able to get everything directly from the source.

**Key Question**: Can the Decipher API replace our current file upload workflow entirely?

---

## Executive Summary

The Decipher API is **significantly more powerful** than initially assumed. It provides:

| Capability | Current Approach | Decipher API Approach |
|------------|------------------|----------------------|
| **Data Map** | User uploads CSV, we parse with state machine | `/datamap` endpoint returns structured JSON with all variables, question relationships, and types |
| **Skip Logic** | Agent infers from context (unreliable) | Questions include `cond` attribute with exact Python conditions |
| **Survey Data** | User uploads SPSS file | `/data` endpoint exports in multiple formats (JSON, CSV, SPSS, etc.) |
| **Survey Structure** | User uploads PDF banner plan | `/datamap` JSON includes full question text, options, and groupings |
| **Variable Relationships** | We infer parent-child relationships | API explicitly provides question → variable mappings |

**Implication**: If we integrate with Decipher API, we could potentially:
1. **Eliminate data map CSV upload** - fetch directly from API
2. **Eliminate SPSS file upload** - fetch directly from API
3. **Eliminate banner plan parsing ambiguity** - generate banner cuts from survey structure
4. **Solve the AND/OR logic problem** - use explicit skip logic from `cond` attributes

---

## Pre-Implementation Requirements

### What a Hawk Partners Person Needs

1. **Decipher Account**: Must have a Forsta Surveys (Decipher) user account
2. **API Key**: Generated from Research Hub → User Links → API Keys
3. **Project Access**: Must have permissions on the specific survey
4. **Survey Path**: The path in format `selfserve/xxxx/yyyy` (e.g., `selfserve/1a2b/mysurvey`)

### API Key Creation

> Using an API Key: visit the Research Hub, and from the User Links menu (click on your picture in the upper right corner), select API Keys. Here you can provision a new API key for yourself or another user created just for API usage. API keys last until revoked or rekeyed.

**Authentication Header**: `x-apikey: [API_KEY]`

**Note**: If a user doesn't have access to create API keys, they need their company administrator to create one on their behalf.

---

## Core API Endpoints

### Base URL
```
https://{your-decipher-server}/api/v1/
```

All requests require HTTPS and the `x-apikey` header.

---

### 1. List Available Surveys

**Endpoint**: `GET /api/v1/rh/companies/all/surveys`

**Purpose**: Get a list of all surveys accessible with the current API key.

**Use Case**: Let users select from a dropdown of their surveys instead of typing a path.

---

### 2. Survey Datamap (THE KEY ENDPOINT)

**Endpoint**: `GET /api/v1/surveys/{survey}/datamap`

**Parameters**:
| Parameter | Values | Description |
|-----------|--------|-------------|
| `format` | `json`, `html`, `text`, `spss_fw`, `sss`, `wincross`, `quantum` | Output format |
| `layout` | layout name | Use a custom data layout |
| `qa` | boolean | Include QA variables |

**Example Request**:
```bash
curl -H "x-apikey: YOUR_KEY" \
  "https://server.decipherinc.com/api/v1/surveys/selfserve/1234/mysurvey/datamap?format=json"
```

**JSON Response Structure**:

The JSON datamap contains two primary arrays:

```typescript
interface DecipherDatamap {
  questions: Question[];   // Question-oriented view (preferred)
  variables: Variable[];   // Variable-oriented view (flat)
}

interface Question {
  qlabel: string;          // Question label (e.g., "Q1")
  qtitle: string;          // Question title/text
  type: string;            // "single", "multiple", "number", "text", etc.
  variables: Variable[];   // Variables generated by this question
  values?: Value[];        // Possible response options
  grouping?: string;       // Logical grouping
  cond?: string;           // SKIP LOGIC CONDITION (Python expression)
}

interface Variable {
  label: string;           // Variable name (e.g., "Q1r1")
  qlabel: string;          // Parent question label
  title: string;           // Descriptive title
  qtitle: string;          // Parent question title
  type: string;            // Variable type
  vgroup: string;          // Variable group
  row?: string;            // Row identifier
  col?: string;            // Column identifier
  rowTitle?: string;       // Row label text
  colTitle?: string;       // Column label text
}

interface Value {
  value: number | string;  // The value code
  label: string;           // The value label
}
```

**Why This Matters**:
- **Replaces our CSV parsing entirely** - no state machine needed
- **Includes `cond` attributes** - explicit skip logic, not inferred
- **Shows question-to-variable mappings** - no parent-child inference needed
- **Contains question text** - could help AI understand intent

---

### 3. Download Survey Data

**Endpoint**: `GET/POST /api/v1/surveys/{survey}/data`

**Parameters**:
| Parameter | Values | Description |
|-----------|--------|-------------|
| `format` | `json`, `csv`, `tab`, `pipe`, `spss`, `xml`, `flat_all` | Output format |
| `layout` | layout name | Custom data layout |
| `fields` | comma-separated | Specific fields to include (e.g., `uuid,date,Q1,Q2`) |
| `start` | ISO 8601 datetime | Start date filter (e.g., `2024-01-01T00:00Z`) |
| `end` | ISO 8601 datetime | End date filter |
| `cond` | Python expression | Filter condition (e.g., `qualified and Q1.r1`) |
| `stacking` | stacking config | For loop/grid unflattening |

**Example Request**:
```bash
curl -H "x-apikey: YOUR_KEY" \
  "https://server.decipherinc.com/api/v1/surveys/selfserve/1234/mysurvey/data?format=json&cond=qualified"
```

**Response**:
```json
{
  "complete": true,
  "data": [
    { "uuid": "abc123", "Q1": 1, "Q2r1": 1, "Q2r2": 0, ... },
    { "uuid": "def456", "Q1": 2, "Q2r1": 0, "Q2r2": 1, ... }
  ]
}
```

**Pagination**: By default, max 10,000 records per request. If `complete: false`, more data exists.

**Why This Matters**:
- **Replaces SPSS file upload** - get data directly
- **Pre-filtered data** - use `cond` to get only qualified respondents
- **JSON format** - no SPSS parsing needed in R, could use native JavaScript

---

### 4. Survey Metadata / Status

**Endpoint**: `GET /api/v1/surveys/{survey}`

**Purpose**: Get survey metadata including status.

**Survey States**:
| State | Description |
|-------|-------------|
| `testing` | Survey has not collected any responses yet |
| `live` | Survey is actively collecting responses |
| `paused` | Survey is paused (for purchased sources) |
| `closed` | Survey can no longer collect responses |

**Why This Matters**:
- Can show users whether a survey is still collecting data
- Might want to handle differently if survey is `testing` vs `live`/`closed`

---

### 5. Data Feed (Real-time Updates)

**Endpoint**: `GET /api/v1/datafeed/{feed}`

**Purpose**: Get new data since last check. Useful for incremental updates.

**Parameters**:
- `start`: Starting point
- `format`: Output format
- `autoAck`: Auto-acknowledge receipt
- `states`: Which survey states to include (default: `live,closed`)
- `paths`: Specific survey paths to include
- `limit`: Max records

**Why This Matters**:
- Could enable "refresh" functionality without re-downloading all data
- Real-time data for live surveys

---

### 6. Data Layouts

**Endpoint**: `GET /api/v1/surveys/{survey}/layouts`

**Purpose**: Get list of custom data layouts with variable configurations.

**Why This Matters**:
- Hawk Partners might have custom layouts already defined
- Could use existing layouts to match their current workflow

---

### 7. Completions Report

**Endpoint**: `GET /api/v1/surveys/{survey}/summary/completions`

**Purpose**: Get completion statistics by segment.

**Why This Matters**:
- Show users survey completion status before processing
- Validate expected sample sizes

---

## Skip Logic / Condition Syntax

The `cond` attribute in Decipher uses Python expressions. Understanding this is critical for interpreting skip logic.

### Basic Syntax

```python
# Single answer selected
Q1.r1                    # True if row 1 selected at Q1

# Multiple conditions
Q1.r1 or Q1.r2           # Either row 1 OR row 2
Q1.r1 and Q2.r1          # Both conditions must be true

# Value comparisons
Q1.ival > 5              # Integer value greater than 5
Q1.ival >= 3 and Q1.ival <= 7  # Range check

# Complex nested
(Q1.r1 or Q1.r2) and Q2.r3
```

### Real Examples from Decipher Documentation

```xml
<!-- Show Q2 only if Q1.r1 (Yes) was selected -->
<radio label="Q1">
  <title>Did you enjoy your vacation?</title>
  <row label="r1">Yes</row>
  <row label="r2">No</row>
</radio>
<suspend/>
<textarea label="Q2" cond="Q1.r1">
  <title>What did you enjoy about your vacation?</title>
</textarea>
```

```xml
<!-- Different follow-ups based on rating -->
<textarea label="Q2a" cond="Q1.c1 or Q1.c2">
  <title>It appears you did not enjoy this survey. How come?</title>
</textarea>
<textarea label="Q2b" cond="Q1.c4 or Q1.c5">
  <title>It appears you enjoyed this survey. How come?</title>
</textarea>
```

### Why This Matters

This is the **exact skip logic** we've been trying to infer! When the datamap shows:

```json
{
  "qlabel": "S2a",
  "cond": "S2 in [6, 7]",
  "qtitle": "In what type of office do you primarily work?"
}
```

We now know that `S2a` is ONLY asked when `S2 in [6, 7]`. So when a banner cut says `S2=1 AND S2a=1`, we can immediately flag this as **logically impossible** (S2a is never asked when S2=1).

---

## Architectural Implications

### Current Flow (File-Based)
```
User uploads:
  ├── Banner Plan (PDF/DOC) → BannerAgent extracts columns
  ├── Data Map (CSV) → State machine parses variables
  └── SPSS File (.sav) → Uploaded for R processing

CrosstabAgent → Validates banner cuts against data map (infers skip logic)
RScriptAgent → Generates R code, executes with SPSS file
```

### Proposed Flow (API-Based)
```
User selects survey from dropdown (API: /surveys)
                ↓
System fetches:
  ├── Datamap (API: /datamap?format=json) → Complete survey structure
  ├── Survey Data (API: /data?format=json) → Respondent data
  └── Survey Status (API: /surveys/{id}) → Live/closed/etc.
                ↓
AI Agent generates banner plan from datamap (OPTIONAL user upload override)
                ↓
CrosstabAgent validates with EXPLICIT skip logic from cond attributes
                ↓
RScriptAgent generates R code (or: use JavaScript with JSON data directly?)
```

### What This Could Eliminate

| Component | Current | With Decipher API |
|-----------|---------|-------------------|
| Data Map CSV Upload | Required | **Eliminated** |
| SPSS File Upload | Required | **Eliminated** (use JSON) |
| Banner Plan Upload | Required | **Optional** (can auto-generate) |
| CSV State Machine Parser | Complex, fragile | **Eliminated** |
| Skip Logic Inference | Unreliable | **Explicit from API** |
| Parent-Child Relationship Guessing | Error-prone | **Explicit from API** |

---

## Test Script Proposal

Create a simple Node.js script to validate API access:

```typescript
// scripts/test-decipher-api.ts

interface TestConfig {
  apiKey: string;
  baseUrl: string;
  surveyPath: string;
}

async function testDecipherAPI(config: TestConfig) {
  const headers = { 'x-apikey': config.apiKey };

  console.log('=== Decipher API Test ===\n');

  // Test 1: Get datamap
  console.log('1. Fetching datamap...');
  const datamapUrl = `${config.baseUrl}/api/v1/surveys/${config.surveyPath}/datamap?format=json`;
  const datamapRes = await fetch(datamapUrl, { headers });

  if (!datamapRes.ok) {
    console.error(`   Failed: ${datamapRes.status} ${datamapRes.statusText}`);
    return;
  }

  const datamap = await datamapRes.json();
  console.log(`   ✓ Found ${datamap.questions?.length || 0} questions`);
  console.log(`   ✓ Found ${datamap.variables?.length || 0} variables`);

  // Test 2: Check for skip logic
  console.log('\n2. Checking for skip logic (cond attributes)...');
  const questionsWithCond = datamap.questions?.filter((q: any) => q.cond) || [];
  console.log(`   ✓ Found ${questionsWithCond.length} questions with conditions`);

  if (questionsWithCond.length > 0) {
    console.log('\n   Sample conditions:');
    questionsWithCond.slice(0, 5).forEach((q: any) => {
      console.log(`   - ${q.qlabel}: cond="${q.cond}"`);
    });
  }

  // Test 3: Get survey data (limited)
  console.log('\n3. Fetching survey data (first 10 records)...');
  const dataUrl = `${config.baseUrl}/api/v1/surveys/${config.surveyPath}/data?format=json&limit=10`;
  const dataRes = await fetch(dataUrl, { headers });

  if (!dataRes.ok) {
    console.error(`   Failed: ${dataRes.status} ${dataRes.statusText}`);
    return;
  }

  const surveyData = await dataRes.json();
  console.log(`   ✓ Retrieved ${surveyData.data?.length || 0} records`);
  console.log(`   ✓ Complete: ${surveyData.complete}`);

  // Test 4: Show sample question structure
  console.log('\n4. Sample question structure:');
  const sampleQ = datamap.questions?.[0];
  if (sampleQ) {
    console.log(JSON.stringify(sampleQ, null, 2));
  }

  console.log('\n=== Test Complete ===');
}

// Run with: npx tsx scripts/test-decipher-api.ts
const config: TestConfig = {
  apiKey: process.env.DECIPHER_API_KEY || '',
  baseUrl: process.env.DECIPHER_BASE_URL || 'https://v2.decipherinc.com',
  surveyPath: process.env.DECIPHER_SURVEY_PATH || 'selfserve/xxxx/yyyy',
};

if (!config.apiKey) {
  console.error('Error: DECIPHER_API_KEY environment variable required');
  process.exit(1);
}

testDecipherAPI(config);
```

**To Run**:
```bash
# Set environment variables
export DECIPHER_API_KEY="your-api-key"
export DECIPHER_BASE_URL="https://your-server.decipherinc.com"
export DECIPHER_SURVEY_PATH="selfserve/1234/mysurvey"

# Execute
npx tsx scripts/test-decipher-api.ts
```

---

## Open Questions

1. **What's Hawk Partners' Decipher server URL?**
   - Common: `v2.decipherinc.com`, but could be custom

2. **Does everyone at Hawk Partners have Decipher access?**
   - If not, we still need fallback to file upload

3. **What permissions are needed?**
   - API key creation requires certain permissions
   - Data access requires project permissions

4. **How is data formatted for multi-select questions?**
   - Need to see actual API response to understand structure

5. **Does the datamap include actual question text?**
   - Critical for AI understanding of survey intent

6. **Can we access closed surveys?**
   - Most crosstabs are for completed studies

7. **Rate limits?**
   - API header `x-usage-today` shows daily usage

---

## Next Steps

1. **Get API credentials from Hawk Partners**
   - Need actual API key and server URL

2. **Run test script on real survey**
   - Validate assumptions about data structure

3. **Examine actual datamap JSON**
   - Confirm `cond` attributes are present and useful

4. **Compare to current CSV data map**
   - Ensure API provides at least equivalent information

5. **Decide on architecture**
   - API-first with file upload fallback?
   - Or both paths fully supported?

---

## Sources

- [Decipher API Documentation](https://release.decipherinc.com/s/local/api.html)
- [Forsta Surveys REST API](https://forstasurveys.zendesk.com/hc/en-us/articles/4409469957531-Forsta-Surveys-REST-API)
- [How to Retrieve a Survey Datamap Using the Forsta Surveys API](https://forstasurveys.zendesk.com/hc/en-us/articles/4409461412251-How-to-Retrieve-a-Survey-Datamap-Using-the-Forsta-Surveys-API)
- [Adding Condition / Skip Logic](https://decipher.zendesk.com/hc/en-us/articles/360010277353-Adding-Condition-Skip-Logic)
- [Decipher Python Package (PyPI)](https://pypi.org/project/decipher/)
- [Survey Metadata API Calls](https://decipher.zendesk.com/hc/en-us/articles/360017549613-Survey-Metadata-API-Calls)
- [Testing and Launching](https://decipher.zendesk.com/hc/en-us/articles/360010274693-Testing-and-Launching)
- [Decipher Survey Sync (GitHub)](https://github.com/glorious-conversation-design/decipher-survey-sync)

---

*Created: January 1, 2026*
*Status: Exploration / Research*
